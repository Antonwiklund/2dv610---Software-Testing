The programs might from the start need to have 4gb RAM allocated.
A full 10gb of RAM and an i5-2520M @ 2.5GHz running on around 80%, was used to get the results.

All the results derive from the time it took for the tests to finish, after the tests had already been run 10 times. The results are gathered from the average time value of the 11th until and including 15h run of the tests. After testrun 5, the tests did not improve much in equalization in relation to the time it took to process each individual test, but there did still exist a somewhat relevant difference in this processing-time, and this was the reason for using test 11 to 15. 
In certain cases, there was a very relevant difference between tests 6-10, and tests 11-15.  
To run the tests beyond the first 15 times however seemed to be irrelevant in relation to the results this produced, as these results seemed to be basically the exact same of those from the 11th to the 15th run of tests. 

The time measured is based upon two methods:
# All the tests were run in a sequential fashion. First test 1, then test 2, and so on. In this sequential fashion, the tests were also run in a for-loop, which ran all the tests 15 times. The reason for this: to make the testing more automated and orderly, making it easier for the observer of the test to analyze the results. This was the faster approach.
# All the tests were run one at a time. Manually starting each and every test. The reason for this: to test every test in an isolated fashion, in order to remove as much possible outside influence over the tests as possible. This was the slower approach. Running the tests like this, I believe, instead added un-necessary amounts of outside influence.

When running the tests in these two different ways, the results were sometimes greatly affected. Some tests doubled their effiency when run in a loop, one almost tripled(SB 80-char-string). All did improve. I believe the reason for this might be found in the way that Java's VM operates when building the necessary environment to run the code presented to it, but I also believe that the reason can be found in the way that the computer allocates the available resources to the JVM(when running the tests manually, every time the current test finishes, allocation of resources is broken. I also assume that various processes surrounding the basic starting of the test, hinders the allocation of resources when starting the test again). 
When running the tests sequentially, the results are also stabilized. The difference in time is reduced. Once again, probably because the computer and the JVM can focus more intently on the tests themselves, removing disturbances. 

Sometimes relatively small changes in the number of append's/concat's resulted in an unproportional growth in the time it would take to finish the tests. Most likely this was due to the garbage collector.

After each test I ran the garbage collector, in order to give the next test the most fresh start possible.

---------------------------------------------------------------------
Results for tests ran manually:
SB single-char-string:		  83400000	length: 83400000
SB 80-char-string:		  2450000	length: 180000000
String concat single-char-string: 40500		length	40500
String concat 80-char-string:     3100		length  248000

InsertionSort int:	 48000	
InsertionSort String:	 32000
MergeSort int:		 28000
MergeSort String:  	 26000
---------------------------------------------------------------------
Results for tests ran sequentially in a foor-loop(Percentage values are very approximate, and shouldn't be taken seriously):		
SB single-char-string:		  90400000 (+10%)	length: 90400000
SB 80-char-string:		  6300000  (+180%)	length: 504000000
String concat single-char-string: 72000	   (+80%)	length: 72000
String concat 80-char-string:	  6700	   (+120%)	length: 608000

InsertionSort int: 	100000	(+100%)
InsertionSort String: 	36000	(+10%)
MergeSort int:  	29000	(+2.5%)
MergeSort String:	27500	(+2.5%)
---------------------------------------------------------------------

In general I'm somewhat satisfied with the experiment. I could however had run each singular test in a loop, instead of running them one and one after each other. It would make more sense, as that probably would produce a more relevant result for the individual tests. 
My general conclusions are that certain solutions solve a problem much faster than others. More so than I thought. I didn't think SB was so much faster than straight concatenation.
Something I'm not happy about when it comes to the experiment, is that after I restarted the computer one time, the InsertionSort for String suddenly lost capacity. It started processing 10% slower. None of the other tests were affected. I had restarted the computer many times prior to this, and then one time this happened. I have no idea (which to me sounds reasonable) why and it's very irritating. It might be because I moved my workspace to run the tests on Linux, and my java version is older on Linux, so I had to convert to 1.7, and then back to 1.8 again when returning to Windows 10. That being the cause seems to me to be pretty unlikely though, as all the code remained the same as previously. Maybe something with my comp, don't know.
When running the tests on Linux on 1.7 Java, some tests were 10% faster, some 10% slower.

---------------------------------------------------------------------

I rebuilt the test, so that each test is looped 15 times individually. I also fixed the bug in both implementations of MergeSort.

For the sorting algorithms, this resulted in slight improvements for MergeSorts, and significant worsening of insertionSort String.

For the string algorithms, this resulted in improved performance of all tests. Especially SB was improved.

There are various aspects which relate to the improvement/worsening of the time measured. These aspects seemingly once again concern the way the JVM functions.
For example: during the first 15 runs of String concat 80-char, the first 10 tests measure 4secs or so, then suddenly at test 11 it falls to 1 sec. This capacity also remains when the loop returns to this test. While for the other tests, the time for the first test to run becomes greater. For SB 80-char-string, it can take up to 22secs to run the first test in the loop.

---------------------------------------------------------------------

Results for tests ran sequentially in a foor-loop(Percentage values are very approximate, and shouldn't be taken seriously):		
SB single-char-string:		  105000000 (+15%)	length: 105000000
SB 80-char-string:		  105000000 (+40%)	length: 840000000
String concat single-char-string: 72000	    (+0%)	length: 72000
String concat 80-char-string:	  7300	    (+10%)	length: 608000

InsertionSort int: 	100000	(+0%)
InsertionSort String: 	31000	(-15%)
MergeSort int:  	30000	(+5%)
MergeSort String:	29000	(+5%)

---------------------------------------------------------------------

StringBuilder is most often faster than straight concatenation, because every time that a string is extended through the use of concatenation, the string is not really extended. Rather, a new String is created. 
For example:
String a = "as"; 
a += "sa";
does not result in the first string adding "sa" to itself. Instead a new 'a'-string is created, to which is added: the value of the original 'a'-string concatenated with the desired extending value. This uses memory and, I would assume, the processor. 
String is immutable. Meaning that it can't be changed once created. That's why a new String has to be created.

A StringBuilder on the other hand is mutable. It's possible to change the StringBuilder string's value. A new StringBuilder string is not necessary for every change which one might want to make to the string. 

It seems that a simple concatenation should sometimes be faster than using a StringBuilder. If the process of concatenation is not repeated more than a few times. Not sure about this though, but it seems reasonable. Creating a StringBuilder also uses resources. 

For the sole purpose of joining strings together, String.join() is apparently faster than SB.
